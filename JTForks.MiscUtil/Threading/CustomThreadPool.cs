// <copyright file="CustomThreadPool.cs" company="MjrTom">
// Copyright (c) Joseph Bridgewater. All rights reserved.
// </copyright>

namespace MiscUtil.Threading
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using MiscUtil.Collections;

    /// <summary>
    /// A thread pool implementation which allows policy decisions
    /// for the number of threads to run, etc, to be programmatically set.
    /// </summary>
    /// <remarks>
    /// Each instance runs with entirely separate threads, so one thread pool
    /// cannot "starve" another one of threads, although having lots of threads
    /// running may mean that some threads are starved of processor time.
    /// If the values for properties such as MinThreads, IdlePeriod etc are changed
    /// after threads have been started, it may take some time before their effects
    /// are noticed. For instance, reducing the idle time from 5 minutes to 1 minute
    /// will not prevent a thread which had only just started to idle from waiting
    /// for 5 minutes before dying. Any exceptions thrown in the work item itself
    /// are handled by the WorkerException event, but all other exceptions are
    /// propagated to the AppDomain's UnhandledException event. This includes
    /// exceptions thrown by the BeforeWorkItem and AfterWorkItem events.
    /// This class is thread-safe - any thread may call any method on any instance of it.
    /// </remarks>
    public class CustomThreadPool
    {
        /// <summary>
        /// Lock around all static members.
        /// </summary>
        private static readonly object staticLock = new();

        /// <summary>
        /// Total number of instances created
        /// </summary>
        private static int instanceCount;

        /// <summary>
        /// Default idle period for new pools
        /// </summary>
        private const int DefaultIdlePeriod = 60000;
        /// <summary>
        /// Default min threads for new pools
        /// </summary>
        private const int DefaultMinThreads = 5;
        /// <summary>
        /// Default max threads for new pools
        /// </summary>
        private const int DefaultMaxThreads = 10;

        /// <summary>
        /// If the idle period is short but we have less than the
        /// minimum number of threads, idle for this long instead,
        /// so as to avoid tight-looping. We don't enforce this
        /// minimum if the thread will die if it idles for its IdlePeriod.
        /// </summary>
        private const int MinWaitPeriod = 60000;

        /// <summary>
        /// If the idle period is long (or infinite) then we shouldn't
        /// actually wait that long, just in case the timeout etc changes.
        /// </summary>
        private const int MaxWaitPeriod = 300000;

        /// <summary>
        /// Creates a new thread pool with an autogenerated name.
        /// </summary>
        public CustomThreadPool()
        {
            lock (staticLock)
            {
                instanceCount++;
                lock (this.stateLock)
                {
                    this.Name = "CustomThreadPool-" + instanceCount;
                }
            }
        }

        /// <summary>
        /// Creates a new thread pool with the specified name
        /// </summary>
        /// <param name="name">The name of the new thread pool</param>
        public CustomThreadPool(string name)
        {
            lock (staticLock)
            {
                instanceCount++;
            }

            lock (this.stateLock)
            {
                this.Name = name;
            }
        }

        /// <summary>
        /// Lock around access to all state other than events and the queue.
        /// The queue lock may be acquired within this lock.
        /// </summary>
        private readonly object stateLock = new();

        /// <summary>
        /// Lock for the queue itself. The state lock must not be acquired within
        /// this lock unless it is already held by the thread.
        /// </summary>
        private readonly object queueLock = new();

        /// <summary>
        /// The queue itself.
        /// </summary>
        private readonly RandomAccessCollection<ThreadPoolWorkItem> queue = [];

        /// <summary>
        /// The number of threads started (in total) by this thread pool.
        /// Used for naming threads.
        /// </summary>
        private int threadCounter;

        /// <summary>
        /// How long a thread may be remain idle for before dying, in ms.
        /// Note that a thread will not die if doing so would
        /// reduce the number of threads below MinThreads. A value of 0 here
        /// indicates that threads should not idle at all (except if the number
        /// of threads would otherwise fall below MinThreads). A value of
        /// Timeout.Infinite indicates that a thread will idle until a new work item
        /// is added, however long that is.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        public int IdlePeriod
        {
            get
            {
                lock (stateLock)
                {
                    return field;
                }
            }
            set
            {
                if (value is < 0 and not Timeout.Infinite)
                {
                    throw new ArgumentException("IdlePeriod must be non-negative.", "IdlePeriod");
                }

                lock (stateLock)
                {
                    field = value;
                }
            }
        }

        = DefaultIdlePeriod;

        /// <summary>
        /// Gets the name of the thread pool.
        /// This is used to set the name of any new threads created by the pool.
        /// </summary>
        public string Name
        {
            get
            {
                lock (this.stateLock)
                {
                    return field;
                }
            }
        }

        private int minThreads = DefaultMinThreads;
        /// <summary>
        /// The minimum number of threads to leave in the pool. Note that
        /// the pool may contain fewer threads than this until work items
        /// have been placed on the queue. A call to StartMinThreads
        /// will make sure that at least MinThreads threads have been started.
        /// This value must be non-negative. Note that a MinThreads value of 0
        /// introduces a possible (although very unlikely) race condition where
        /// a work item may be added to the queue just as the last thread decides
        /// to exit. In this case, the work item would not be executed until the
        /// next work item was added.
        /// TODO: Try to remove this race condition
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        public int MinThreads
        {
            get
            {
                lock (this.stateLock)
                {
                    return this.minThreads;
                }
            }
            set
            {
                ArgumentOutOfRangeException.ThrowIfNegative(value);

                lock (this.stateLock)
                {
                    ArgumentOutOfRangeException.ThrowIfGreaterThan(value, this.maxThreads, nameof(value));

                    this.minThreads = value;
                }
            }
        }

        private int maxThreads = DefaultMaxThreads;
        /// <summary>
        /// The maximum number of threads to allow to be in the pool at any
        /// one time. This value must be greater than or equal to 1.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        public int MaxThreads
        {
            get
            {
                lock (this.stateLock)
                {
                    return this.maxThreads;
                }
            }
            set
            {
                ArgumentOutOfRangeException.ThrowIfLessThan(value, 1, nameof(value));

                lock (this.stateLock)
                {
                    ArgumentOutOfRangeException.ThrowIfLessThan(value, this.minThreads, nameof(value));

                    this.maxThreads = value;
                }
            }
        }

        /// <summary>
        /// Sets both the minimum and maximum number of threads, atomically. This prevents
        /// exceptions which might occur when setting properties individually (e.g. going
        /// from (min=5, max=10) to (min=15, max=20), if the minimum were changed first,
        /// an exception would occur.
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        public void SetMinMaxThreads(int min, int max)
        {
            lock (this.stateLock)
            {
                this.MinThreads = 0;
                this.MaxThreads = max;
                this.MinThreads = min;
            }
        }

        /// <summary>
        /// The number of work items currently awaiting execution.
        /// This does not include work items currently being executed.
        /// </summary>
        public int QueueLength
        {
            get
            {
                lock (this.queueLock)
                {
                    return this.queue.Count;
                }
            }
        }

        private int workingThreads;
        /// <summary>
        /// The number of threads currently executing work items
        /// or BeforeWorkItem/AfterWorkItem/WorkerException events.
        /// </summary>
        public int WorkingThreads
        {
            get
            {
                lock (this.stateLock)
                {
                    return this.workingThreads;
                }
            }
        }

        /// <summary>
        /// The total number of threads in the pool at the present time.
        /// </summary>
        public int TotalThreads { get; private set; }

        private ThreadPriority workerThreadPriority = ThreadPriority.Normal;
        /// <summary>
        /// The priority of worker threads. Each thread's priority is set
        /// before the BeforeWorkItem event and after the AfterWorkItem event.
        /// The priority of an individual thread may be changed in
        /// the BeforeWorkItem event, and that changed priority
        /// will remain active for the duration of the work item itself.
        /// The default is ThreadPriority.Normal.
        /// </summary>
        public ThreadPriority WorkerThreadPriority
        {
            get
            {
                lock (stateLock)
                {
                    return workerThreadPriority;
                }
            }
            set
            {
                lock (stateLock)
                {
                    workerThreadPriority = value;
                }
            }
        }

        private bool workerThreadsAreBackground = true;
        /// <summary>
        /// Whether or not worker threads should be created and
        /// set as background threads. This is set for the thread before
        /// the BeforeWorkItem event and after the AfterWorkItem event.
        /// The background status of a thread may be changed in the BeforeWorkItem
        /// event, and that changed status will remain active for the duration
        /// of the work item itself. Default is true.
        /// </summary>
        public bool WorkerThreadsAreBackground
        {
            get
            {
                lock (this.stateLock)
                {
                    return this.workerThreadsAreBackground;
                }
            }
            set
            {
                lock (this.stateLock)
                {
                    this.workerThreadsAreBackground = value;
                }
            }
        }

        /// <summary>
        /// Lock around all access to events.
        /// </summary>
        private readonly object eventLock = new();

        private ThreadPoolExceptionHandler? exceptionHandler;
        /// <summary>
        /// Event which is fired if a worker thread throws an exception in
        /// its work item.
        /// </summary>
        public event ThreadPoolExceptionHandler WorkerException
        {
            add
            {
                lock (this.eventLock)
                {
                    this.exceptionHandler += value;
                }
            }
            remove
            {
                lock (this.eventLock)
                {
                    this.exceptionHandler -= value;
                }
            }
        }

        /// <summary>
        /// Raises the WorkerException event.
        /// TODO: Write to the event log if no exception handlers are attached?
        /// </summary>
        /// <param name="workItem"></param>
        /// <param name="e"></param>
        private void OnException(ThreadPoolWorkItem workItem, Exception e)
        {
            ThreadPoolExceptionHandler? eh;
            lock (this.eventLock)
            {
                eh = this.exceptionHandler;
            }

            if (eh != null)
            {
                Delegate[] delegates = eh.GetInvocationList();
                var handled = false;
                foreach (ThreadPoolExceptionHandler d in delegates)
                {
                    d(this, workItem, e, ref handled);
                    if (handled)
                    {
                        return;
                    }
                }
            }
        }

        /// <summary>
        /// Delegate for the BeforeWorkItem event.
        /// </summary>
        private BeforeWorkItemHandler? beforeWorkItem;
        /// <summary>
        /// Event fired before a worker thread starts a work item.
        /// </summary>
        public event BeforeWorkItemHandler BeforeWorkItem
        {
            add
            {
                lock (this.eventLock)
                {
                    this.beforeWorkItem += value;
                }
            }
            remove
            {
                lock (this.eventLock)
                {
                    this.beforeWorkItem -= value;
                }
            }
        }

        /// <summary>
        /// Raises the BeforeWorkItem event
        /// </summary>
        /// <param name="workItem">The work item which is about to execute</param>
        /// <param name="cancel">Whether or not the work item was cancelled by an event handler</param>
        private void OnBeforeWorkItem(ThreadPoolWorkItem workItem, out bool cancel)
        {
            cancel = false;
            BeforeWorkItemHandler? delegateToFire;
            lock (this.eventLock)
            {
                delegateToFire = this.beforeWorkItem;
            }

            if (delegateToFire != null)
            {
                Delegate[] delegates = delegateToFire.GetInvocationList();
                foreach (BeforeWorkItemHandler d in delegates)
                {
                    d(this, workItem, ref cancel);
                    if (cancel)
                    {
                        return;
                    }
                }
            }
        }

        /// <summary>
        /// Delegate for the AfterWorkItem event.
        /// </summary>
        private AfterWorkItemHandler? afterWorkItem;
        /// <summary>
        /// Event fired after a worker thread successfully finishes a work item.
        /// This event is not fired if the work item throws an exception.
        /// </summary>
        public event AfterWorkItemHandler AfterWorkItem
        {
            add
            {
                lock (this.eventLock)
                {
                    this.afterWorkItem += value;
                }
            }
            remove
            {
                lock (this.eventLock)
                {
                    this.afterWorkItem -= value;
                }
            }
        }

        /// <summary>
        /// Raises the AfterWorkItem event
        /// </summary>
        /// <param name="workItem"></param>
        private void OnAfterWorkItem(ThreadPoolWorkItem workItem)
        {
            AfterWorkItemHandler? delegateToFire;
            lock (this.eventLock)
            {
                delegateToFire = this.afterWorkItem;
            }

            delegateToFire?.Invoke(this, workItem);
        }

        /// <summary>
        /// Delegate for the ThreadExit event.
        /// </summary>
        private ThreadProgress? workerThreadExit;
        /// <summary>
        /// Event called just before a thread dies.
        /// </summary>
        public event ThreadProgress WorkerThreadExit
        {
            add
            {
                lock (this.eventLock)
                {
                    this.workerThreadExit += value;
                }
            }
            remove
            {
                lock (this.eventLock)
                {
                    this.workerThreadExit -= value;
                }
            }
        }

        /// <summary>
        /// Raises the WorkerThreadExit event and decrements the number of total worker threads
        /// </summary>
        private void OnWorkerThreadExit()
        {
            try
            {
                ThreadProgress? delegateToFire;
                lock (this.eventLock)
                {
                    delegateToFire = this.workerThreadExit;
                }

                delegateToFire?.Invoke(this);
            }
            catch
            {
                // Don't do anything if this event throws an exception
            }

            lock (this.stateLock)
            {
                this.TotalThreads--;
            }
        }

        /// <summary>
        /// Ensures that the pool has at least the minimum number of threads.
        /// </summary>
        public void StartMinThreads()
        {
            lock (this.stateLock)
            {
                while (this.TotalThreads < this.MinThreads)
                {
                    this.StartWorkerThread();
                }
            }
        }

        /// <summary>
        /// Adds a work item to the queue, starting a new thread if appropriate.
        /// </summary>
        /// <param name="workItemDelegate">The delegate representing the work item</param>
        /// <param name="parameters">The parameters to pass to the delegate</param>
        /// <exception cref="ArgumentNullException"><paramref name="workItemDelegate"/> is <c>null</c>.</exception>
        public void AddWorkItem(Delegate workItemDelegate, params object[] parameters)
        {
            ArgumentNullException.ThrowIfNull(workItemDelegate);

            this.AddWorkItem(new ThreadPoolWorkItem(workItemDelegate, parameters));
        }

        /// <summary>
        /// Adds a work item to the queue, starting a new thread if appropriate.
        /// </summary>
        /// <param name="workItemDelegate">The delegate representing the work item.</param>
        /// <exception cref="ArgumentNullException"><paramref name="workItemDelegate"/> is <c>null</c>.</exception>
        public void AddWorkItem(Delegate workItemDelegate)
        {
            ArgumentNullException.ThrowIfNull(workItemDelegate);

            this.AddWorkItem(new ThreadPoolWorkItem(workItemDelegate, null!));
        }

        /// <summary>
        /// Adds a work item to the queue and potentially start a new thread.
        /// A thread is started if there are no idle threads or if there is already
        /// something on the queue - but in each case, only if the total number of
        /// threads is less than the maximum.
        /// </summary>
        /// <param name="workItem">The actual work item to add to the queue.</param>
        /// <exception cref="ArgumentNullException"><paramref name="workItem"/> is <c>null</c>.</exception>
        public void AddWorkItem(ThreadPoolWorkItem workItem)
        {
            ArgumentNullException.ThrowIfNull(workItem);

            bool startNewThread;
            lock (this.stateLock)
            {
                lock (this.queueLock)
                {
                    if (this.queue.Count == 0)
                    {
                        this.queue.Add(workItem);
                    }
                    else
                    {
                        // Work out where in the queue the item should go

                        // Common case: it belongs at the end
                        if (((ThreadPoolWorkItem)this.queue[^1]).Priority >= workItem.Priority)
                        {
                            this.queue.Add(workItem);
                        }
                        else
                        {
                            // This will find the complement of the correct position, due to the
                            // "interesting" nature of PriorityComparer.
                            var position = this.queue.BinarySearch(workItem, PriorityComparer.Instance);
                            this.queue.Enqueue(workItem, ~position);
                        }
                    }

                    startNewThread = (this.WorkingThreads + this.queue.Count > this.TotalThreads) &&
                                     (this.TotalThreads < this.MaxThreads);
                    // Always pulse the queueLock, whether there's something waiting or not.
                    // This is easier than trying to work out for sure whether or not it's
                    // worth pulsing, and errs on the side of caution.
                    Monitor.Pulse(this.queueLock);
                }
            }

            if (startNewThread)
            {
                this.StartWorkerThread();
            }
        }

        /// <summary>
        /// Cancels the first work item with the specified ID, if there is one.
        /// Note that items which have been taken off the queue and are running
        /// or about to be started cannot be cancelled.
        /// </summary>
        /// <param name="id">The ID of the work item to cancel</param>
        /// <exception cref="ArgumentNullException"><paramref name="id"/> is <c>null</c>.</exception>
        public bool CancelWorkItem(object id)
        {
            ArgumentNullException.ThrowIfNull(id);

            lock (this.queueLock)
            {
                for (var i = 0; i < this.queue.Count; i++)
                {
                    var item = (ThreadPoolWorkItem)this.queue[i];
                    var otherID = item.ID;
                    if (otherID != null && id.Equals(otherID))
                    {
                        this.queue.RemoveAt(i);
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Cancels all work items in the queue.
        /// Note that items which have been taken off the queue and are running
        /// or about to be started cannot be cancelled.
        /// </summary>
        public void CancelAllWorkItems()
        {
            lock (this.queueLock)
            {
                this.queue.Clear();
            }
        }

        /// <summary>
        /// Starts a new worker thread.
        /// </summary>
        private void StartWorkerThread()
        {
            bool background;
            lock (this.stateLock)
            {
                this.threadCounter++;
                this.TotalThreads++;
                background = this.workerThreadsAreBackground;
            }

            Thread thread = new(new ThreadStart(this.WorkerThreadLoop))
            {
                Name = this.Name + " thread " + this.threadCounter,
                IsBackground = background
            };
            thread.Start();
        }

        /// <summary>
        /// Main worker thread loop. This picks jobs off the queue and executes
        /// them, until it's time to die.
        /// </summary>
        private void WorkerThreadLoop()
        {
            // Big try/finally block just to decrement the number of threads whatever happens.
            try
            {
                DateTime lastJob = DateTime.UtcNow;
                while (true)
                {
                    lock (this.stateLock)
                    {
                        if (this.TotalThreads > this.MaxThreads)
                        {
                            return;
                        }
                    }

                    var waitPeriod = this.CalculateWaitPeriod(lastJob);

                    ThreadPoolWorkItem? job = this.GetNextWorkItem(waitPeriod);

                    // No job? Check whether or not we should die
                    if (job == null)
                    {
                        if (this.CheckIfThreadShouldQuit(lastJob))
                        {
                            return;
                        }
                    }
                    else
                    {
                        this.ExecuteWorkItem(job);
                        lastJob = DateTime.UtcNow;
                    }
                }
            }
            finally
            {
                this.OnWorkerThreadExit();
            }
        }

        /// <summary>
        /// Work out how long to wait for in this iteration. If the thread isn't going
        /// to die even if the wait completes, make the idle timeout at least MinWaitPeriod
        /// so we don't end up with lots of threads stealing CPU by checking too often.
        /// </summary>
        /// <param name="lastJob">The time this thread last finished executing a work item.</param>
        /// <returns></returns>
        private int CalculateWaitPeriod(DateTime lastJob)
        {
            lock (this.stateLock)
            {
                var waitPeriod = this.IdlePeriod;
                // Work out how long to actually wait for
                if (waitPeriod != Timeout.Infinite)
                {
                    waitPeriod = (int)(DateTime.UtcNow - lastJob).TotalMilliseconds;
                    // If the idle period has expired, idle for no time.
                    if (waitPeriod < 0)
                    {
                        waitPeriod = 0;
                    }
                }

                // Do we need to raise the waiting period?
                if (this.TotalThreads <= this.MinThreads &&
                    waitPeriod < MinWaitPeriod &&
                    waitPeriod != Timeout.Infinite)
                {
                    waitPeriod = MinWaitPeriod;
                }

                // Do we need to lower the waiting period?
                if (waitPeriod is > MaxWaitPeriod or
                      Timeout.Infinite)
                {
                    waitPeriod = MaxWaitPeriod;
                }

                return waitPeriod;
            }
        }

        /// <summary>
        /// Retrieves the next work item from the queue, pausing for at most
        /// the specified amount of time.
        /// </summary>
        /// <param name="waitPeriod">
        /// The maximum amount of time to wait for a work item to arrive, in ms.
        /// </param>
        /// <returns>
        /// The next work item, or null if there aren't any after waiting
        /// for the specified period.
        /// </returns>
        private ThreadPoolWorkItem? GetNextWorkItem(int waitPeriod)
        {
            lock (this.queueLock)
            {
                if (this.queue.Count != 0)
                {
                    return (ThreadPoolWorkItem)this.queue.Dequeue();
                }
                else
                {
                    Monitor.Wait(this.queueLock, waitPeriod);
                    return this.queue.Count != 0 ? (ThreadPoolWorkItem)this.queue.Dequeue() : null;
                }
            }
        }

        /// <summary>
        /// Checks whether or not this thread should exit, based on the current number
        /// of threads and the time that this thread last finished executing a work item.
        /// </summary>
        /// <param name="lastJob">The time this thread last finished executing a work item.</param>
        /// <returns>Whether or not the thread is "spare" and should thus quit</returns>
        private bool CheckIfThreadShouldQuit(DateTime lastJob)
        {
            lock (this.stateLock)
            {
                if (this.TotalThreads > this.MinThreads)
                {
                    TimeSpan actualIdle = DateTime.UtcNow - lastJob;
                    if (this.IdlePeriod != Timeout.Infinite &&
                        this.IdlePeriod < actualIdle.TotalMilliseconds)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        /// <summary>
        /// Executes the given work item, firing the BeforeWorkItem and AfterWorkItem events,
        /// and incrementing and decrementing the number of working threads.
        /// </summary>
        /// <param name="job">The work item to execute</param>
        private void ExecuteWorkItem(ThreadPoolWorkItem job)
        {
            lock (this.stateLock)
            {
                this.workingThreads++;
                Thread.CurrentThread.Priority = workerThreadPriority;
                Thread.CurrentThread.IsBackground = this.workerThreadsAreBackground;
            }

            try
            {
                this.OnBeforeWorkItem(job, out var cancel);
                if (cancel)
                {
                    return;
                }

                try
                {
                    job.Invoke();
                }
                catch (Exception e)
                {
                    this.OnException(job, e);
                    return;
                }

                this.OnAfterWorkItem(job);
            }
            finally
            {
                lock (this.stateLock)
                {
                    Thread.CurrentThread.Priority = workerThreadPriority;
                    Thread.CurrentThread.IsBackground = this.workerThreadsAreBackground;
                    this.workingThreads--;
                }
            }
        }

        /// <summary>
        /// Comparer which compares an integer priority with the priority of a work item.
        /// Must only be used in the appropriate order (CompareTo(int, WorkItem)). Also,
        /// 0 is never returned by the method - effectively, the given priority is raised by
        /// 0.5, so that when a binary search is used, the value is never found but the returned
        /// index is always the bitwise complement of the correct insertion point.
        /// </summary>
        private class PriorityComparer : IComparer<ThreadPoolWorkItem>
        {
            /// <summary>
            /// Access to single instance of PriorityComparer.
            /// </summary>
            internal static readonly IComparer<ThreadPoolWorkItem> Instance = new PriorityComparer();

            /// <summary>
            /// Private constructor to prevent instantiation
            /// </summary>
            private PriorityComparer()
            {
            }

            /// <summary>
            /// Implementation of IComparer.Compare - see class remarks for details.
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <exception cref="ArgumentException"></exception>
            public int Compare(ThreadPoolWorkItem? x, ThreadPoolWorkItem? y)
            {
                return x == null
                    ? throw new ArgumentException(null, nameof(x))
                    : y == null ? throw new ArgumentException(null, nameof(y)) : x.Priority < y.Priority ? 1 : -1;
            }
        }
    }
}
